<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ASPiK SDK: Design the Sub-Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ASPiK SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('cs2.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Design the Sub-Controller </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The sub-controller is implemented as a C++ object that is derived from IController, the VSTGUI4 interface that "listens" to the controls in our group (two knobs and one button in total). In addition, at creation time, any controls that share the same sub-controller object will be registered with the sub-controller during a function called <b>verifyView</b> that will be called once for each control in the group. It is in this function that we will pick up and store pointers to all of the CAnimKnobs in the group. We will also be looking for, and will store the pointer to the CTextButton that will be the linking control. Before going on, you need to understand how sub-controllers get connected to GUI controls.<br />
 <br />
 <b>Single Controls</b><br />
 If you want to add a sub-controller to a single control (and there are valid reasons for doing this), then you just set the "sub-controller" attribute string in the GUI Designer (it is usually just below the "custom-view-name" entry field). At creation time, the sub-controller will be registered (by the VSTGUI core) and then <b>verifyView</b> will get called for the object. The sub-controller can then save a pointer to the object for use during operation.<br />
 <br />
 <b>Multiple Controls</b><br />
 If you want a sub-controller to operate on a set of controls that are all connected to it, then the trick in VSTGUI4 is to create a CViewContainer object to hold all of the controls and <b>set the CViewContainer's sub-controller string in the GUI designer. The CViewContainer will be created first and will then trigger the creation of the sub-controller</b>. After that, each GUI control inside of this container that will be visible will be registered with the sub-controller object via the <b>verifyView</b> method. In this way, all of the objects can share a common sub-controller that will cache pointers to the items in the group and operate on them. This idea can be extended to nested sets of CViewContainer objects as well!<br />
 <br />
 <b>Sub-Controller Members</b><br />
 • We will need a way to store pointers to all of the CAnimKnobs in the group; we can use a std::vector for that <br />
 • We know that there will be one and only one CTextButton for the link control, so we can just declare a single pointer for it <br />
 • We are going to also cache a pointer to the parent object that creates the sub-controller, which is the PluginGUI - it is also a IController subclassed object! We'll handle the stuff we need to make our knobs link together, and then we'll forward our unused calls back to the parent IController for further processing. You can approach this design from several vantage points, and this strategy will allow us to only minimally affect the GUI operation, with all other chores handled on the parent object. <br />
 <br />
 The sub-controller is defined in the <a class="el" href="customviews_8h.html" title="interface file for example ASPiK custom view and custom sub-controller objects, includes waveform vie...">customviews.h</a> file near the bottom so be sure to follow along in that code:<br />
 <br />
 <b>class KnobLinkController : public IController</b><br />
 {<br />
 &emsp;// snipped coded<br />
 <b>protected:</b><br />
 &emsp;// &mdash; the parent controller; we can issue IController commands to it!<br />
 &emsp;<b>IController* parentController = nullptr;</b><br />
 <br />
 &emsp;// &mdash; a CTextButton is the switcher (linkControl)<br />
 &emsp;<b>CTextButton* linkControl = nullptr;</b><br />
 <br />
 &emsp;// &mdash; when linked, all of these controls move when one of them moves,<br />
 &emsp;// regardless of their control tags<br />
 &emsp;<b>typedef std::vector&lt;CAnimKnob*&gt; KnobList;</b><br />
 &emsp;<b>KnobList linkedKnobs;</b><br />
 <br />
 &emsp;// &mdash; flag for linking knobs<br />
 &emsp;<b>bool linkControls = false;</b><br />
 };<br />
 <br />
 <b>Constructor</b><br />
 In the sub-controller constructor, we will cache the parent pointer and reset the boolean linking flag:<br />
 <br />
 <b>KnobLinkController(IController* _parentController)</b><br />
 {<br />
 &emsp;// &mdash; save the parent listener<br />
 &emsp;<b>parentController = _parentController;</b><br />
 <br />
 &emsp;// &mdash; INITIALIZE LINK STATE<br />
 &emsp;<b>linkControls = false;</b><br />
 }<br />
 <br />
 <b>IController Overrides</b><br />
 There are multiple ways to handle the sub-controller functionality and in our case we will have a fairly simple setup. You should first read the documentation for the IController in the VSTGUI4 SDK (it uses Doxygen as well for documenting the library). You can find the IController interface in the ..\vstgui4\vstgui\uidescription\icontroller.h file. <br />
 <br />
 Here are a list of the functions we'll override and implement with a brief note on their operation:<br />
 <br />
 <b>virtual CView* verifyView(CView* view, const UIAttributes&amp; attributes, const IUIDescription* description)</b><br />
 • we will check the incoming CView* to test if it is a CAnimKnob or a CTextButton <br />
 • if it is a knob we will add it to our std::vector list <br />
 • if it is the button, we will set it as the linking device <br />
 • we will check the button to see if it is already pressed at creation time (it could be a saved state or preset) and we will set our boolean flag if so <br />
 <br />
 The fundamental code is here:<br />
 <br />
 <b>CAnimKnob* knob = dynamic_cast&lt;CAnimKnob*&gt;(view);</b><br />
 <b>CTextButton* button = dynamic_cast&lt;CTextButton*&gt;(view);</b><br />
 <br />
 // &mdash; save button, push back knob onto list<br />
 <b>if (button)</b><br />
 {<br />
 &emsp;<b>linkControl = button;</b><br />
 &emsp;if (button-&gt;getValueNormalized() != 0)<br />
 &emsp;&emsp;linkControls = true;<br />
 &emsp;else<br />
 &emsp;&emsp;linkControls = false;<br />
 }<br />
 <b>else if (knob)</b><br />
 &emsp;<b>linkedKnobs.push_back(knob);</b><br />
 <br />
 <br />
 <b>virtual void valueChanged(CControl* control) </b><br />
 • we will check the incoming CControl* - if it is the link button, we'll set our flag <br />
 • if it is one of the knobs, we will check its value and if the linking flag is set, we will set all the other knobs in the list to match <br />
 • after any changes are applied, we will forward the call to the parent's valueChanged( ) function for further processing. <br />
 <br />
 <b>virtual void valueChanged(CControl* control) </b><br />
 // &mdash; snipped code<br />
 <b>if (control == linkControl)</b><br />
 {<br />
 &emsp;<b>if (control-&gt;getValueNormalized() != 0)</b><br />
 &emsp;&emsp;<b>linkControls = true;</b><br />
 &emsp;<b>else</b><br />
 &emsp;&emsp;<b>linkControls = false;</b><br />
 <br />
 &emsp;<b>return parentController-&gt;valueChanged(control);</b><br />
 }<br />
 <br />
 To set all the knobs together, we just iterate the list of controls:<br />
 <br />
 &mdash; iterate list<br />
 <b>for (std::vector&lt;CAnimKnob*&gt;::iterator itr = linkedKnobs.begin(); itr != linkedKnobs.end(); ++itr)</b><br />
 {<br />
 &emsp;// &mdash; set the control value for all knobs except the one generating this message<br />
 &emsp;<b>CControl* ctrl = *itr;</b><br />
 <br />
 &emsp;<b>if (ctrl &amp;&amp; control != ctrl)</b><br />
 &emsp;{<br />
 &emsp;&emsp;// &mdash; set the control visually<br />
 &emsp;&emsp;<b>ctrl-&gt;setValueNormalized(control-&gt;getValueNormalized());</b><br />
 <br />
 &emsp;&emsp;// &mdash; do the value change at parent level, to set on plugin<br />
 &emsp;&emsp;<b>parentController-&gt;valueChanged(ctrl);</b><br />
 &emsp;}<br />
 }<br />
 <br />
 <b>virtual CView* createView(const UIAttributes&amp; attributes, const IUIDescription* description)</b><br />
 <b>virtual void controlBeginEdit(CControl* pControl)</b><br />
 <b>virtual void controlEndEdit(CControl* pControl)</b><br />
 <b>virtual void controlTagWillChange(CControl* pControl)</b><br />
 <b>virtual void controlTagDidChange(CControl* pControl)</b><br />
 • For the rest of these functions, we will forward the function call to the parent (see the code - it is straightforward)<br />
 <br />
 Notice how the sub-controller intelligently handles the connections between the GUI objects and that it is coded in the GUI portion of the ASPiK project - the <a class="el" href="class_plugin_core.html" title="The PluginCore object is the default PluginBase derived object for ASPiK projects. Note that you are fre to change the name of this object (as long as you change it in the compiler settings, etc...) ">PluginCore</a> does not know of the sub-controller's existence (in this case, but that is possible - see below). This is the proper way to handle this kind of arrangement of control functions and you should use the sub-controller paradigm for this kind of GUI customization.<br />
 <br />
 With the sub-controller link in place, we need to modify the <b>PluginGUI::createSubController( )</b> function to decode the incoming sub-controller name string and create the device:<br />
 <br />
 <b>IController* PluginGUI::createSubController(UTF8StringPtr name, const IUIDescription* description)</b><br />
 {<br />
 &emsp;<b>std::string strName(name);</b><br />
 &emsp;<b>int findIt = strName.find("KnobLinkController");</b><br />
 &emsp;if (findIt &gt;= 0)<br />
 &emsp;{<br />
 &emsp;// &mdash; create the sub-controller<br />
 &emsp;<b>KnobLinkController* knobLinker = new KnobLinkController(this);</b><br />
 <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">ASPiK Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="gui_design.html">Design a GUI</a></li><li class="navelem"><a class="el" href="define_g_u_i6.html">Advanced GUI Topics</a></li><li class="navelem"><a class="el" href="gui_designer12.html">Custom Sub-Controllers</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
